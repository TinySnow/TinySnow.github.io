# 最近更新 | Last Updated

## Prenote

<p style="font-size: larger; font-weight: bold; color: red; text-align: center;">NOTICE: This content is presented as `git diff`.</p>

## SUMMARY.md

```diff

@@ -281,6 +281,59 @@
     - [第二章：计算机的构成](技术/计算机科学极简入门指南/第二章：计算机的构成.md)
     - [第三章：简单逻辑门](技术/计算机科学极简入门指南/第三章：简单逻辑门.md)
     - [第四章：负数与减法](技术/计算机科学极简入门指南/第四章：负数与减法.md)
+    - [第五章：乘法与除法](技术/计算机科学极简入门指南/第五章：乘法与除法.md)
+    - [第六章：算术逻辑单元](技术/计算机科学极简入门指南/第六章：算术逻辑单元.md)
+    - [第七章：存储器](技术/计算机科学极简入门指南/第七章：存储器.md)
+    - [第八章：控制器](技术/计算机科学极简入门指南/第八章：控制器.md)
+    - [第九章：指令系统](技术/计算机科学极简入门指南/第九章：指令系统.md)
+    - [第十章：中央处理器](技术/计算机科学极简入门指南/第十章：中央处理器.md)
+    - [第十一章：总线](技术/计算机科学极简入门指南/第十一章：总线.md)
+    - [第十二章：指令流水线](技术/计算机科学极简入门指南/第十二章：指令流水线.md)
+    - [第十三章：输入输出系统](技术/计算机科学极简入门指南/第十三章：输入输出系统.md)
+    - [第十四章：计算机组成原理](技术/计算机科学极简入门指南/第十四章：计算机组成原理.md)
+    - [第十五章：汇编语言](技术/计算机科学极简入门指南/第十五章：汇编语言.md)
+    - [第十六章：高级语言](技术/计算机科学极简入门指南/第十六章：高级语言.md)
+    - [第十七章：程序与编译](技术/计算机科学极简入门指南/第十七章：程序与编译.md)
+    - [第十八章：程序竞争](技术/计算机科学极简入门指南/第十八章：程序竞争.md)
+    - [第十九章：进程](技术/计算机科学极简入门指南/第十九章：进程.md)
+    - [第二十章：死锁](技术/计算机科学极简入门指南/第二十章：死锁.md)
+    - [第二十一章：存储器管理](技术/计算机科学极简入门指南/第二十一章：存储器管理.md)
+    - [第二十二章：设备管理](技术/计算机科学极简入门指南/第二十二章：设备管理.md)
+    - [第二十三章：文件与文件系统](技术/计算机科学极简入门指南/第二十三章：文件与文件系统.md)
+    - [第二十四章：操作系统](技术/计算机科学极简入门指南/第二十四章：操作系统.md)
+    - [第二十四章（附加）：操作系统加载](技术/计算机科学极简入门指南/第二十四章（附加）：操作系统加载.md)
+    - [第二十五章：尝试互联](技术/计算机科学极简入门指南/第二十五章：尝试互联.md)
+    - [第二十六章：协议分层](技术/计算机科学极简入门指南/第二十六章：协议分层.md)
+    - [第二十七章：路由跳转](技术/计算机科学极简入门指南/第二十七章：路由跳转.md)
+    - [第二十八章：路径选择](技术/计算机科学极简入门指南/第二十八章：路径选择.md)
+    - [第二十九章：路由洪泛与广播](技术/计算机科学极简入门指南/第二十九章：路由洪泛与广播.md)
+    - [第三十章：数据包的封装与拆解](技术/计算机科学极简入门指南/第三十章：数据包的封装与拆解.md)
+    - [第三十一章：状态码与协议森林](技术/计算机科学极简入门指南/第三十一章：状态码与协议森林.md)
+    - [第三十二章：计算机网络](技术/计算机科学极简入门指南/第三十二章：计算机网络.md)
+    - [第三十三章：数据结构与算法综述](技术/计算机科学极简入门指南/第三十三章：数据结构与算法综述.md)
+    - [第三十四章：数据结构](技术/计算机科学极简入门指南/第三十四章：数据结构.md)
+    - [第三十五章：算法](技术/计算机科学极简入门指南/第三十五章：算法.md)
+    - [第三十六章：从字符串变为程序](技术/计算机科学极简入门指南/第三十六章：从字符串变为程序.md)
+    - [第三十七章：词法分析](技术/计算机科学极简入门指南/第三十七章：词法分析.md)
+    - [第三十八章：语法分析](技术/计算机科学极简入门指南/第三十八章：语法分析.md)
+    - [第三十九章：中间代码生成](技术/计算机科学极简入门指南/第三十九章：中间代码生成.md)
+    - [第四十章：代码优化](技术/计算机科学极简入门指南/第四十章：代码优化.md)
+    - [第四十一章：目标代码生成](技术/计算机科学极简入门指南/第四十一章：目标代码生成.md)
+    - [第四十二章：操作系统装载](技术/计算机科学极简入门指南/第四十二章：操作系统装载.md)
+    - [第四十三章（终章）：计算机极简入门指南总览](技术/计算机科学极简入门指南/第四十三章（终章）：计算机极简入门指南总览.md)
+    - [附加章一：大数据](技术/计算机科学极简入门指南/附加章一：大数据.md)
+    - [附加章二：数据加密](技术/计算机科学极简入门指南/附加章二：数据加密.md)
+    - [附加章三：区块链](技术/计算机科学极简入门指南/附加章三：区块链.md)
+    - [附加章四：人工智能](技术/计算机科学极简入门指南/附加章四：人工智能.md)
+    - [附加章五：数据备份](技术/计算机科学极简入门指南/附加章五：数据备份.md)
+    - [附加章六：量子计算机](技术/计算机科学极简入门指南/附加章六：量子计算机.md)
+    - [附加章七：晶体管](技术/计算机科学极简入门指南/附加章七：晶体管.md)
+    - [附加章八：数据一致性](技术/计算机科学极简入门指南/附加章八：数据一致性.md)
+    - [附加章九：信息科学与数学](技术/计算机科学极简入门指南/附加章九：信息科学与数学.md)
+    - [附加章十：测试](技术/计算机科学极简入门指南/附加章十：测试.md)
+    - [附加章十一：漏洞与病毒](技术/计算机科学极简入门指南/附加章十一：漏洞与病毒.md)
+    - [附加章十二：永不止息的安全与攻防](技术/计算机科学极简入门指南/附加章十二：永不止息的安全与攻防.md)
+    - [附加章十三（终章）：计算机科学的未来](技术/计算机科学极简入门指南/附加章十三（终章）：计算机科学的未来.md)
   - [Java](技术/Java/Java.md)
     - [集合](技术/Java/集合.md)
     - [Java Threads](技术/Java/JavaThreads.md)
```

## sitemap.txt

```diff

@@ -79,6 +79,7 @@ https://tinysnow.github.io/每日一文/在什么地方活着 - 小川未明
 https://tinysnow.github.io/每日一文/垃圾工 - 雷 · 布拉德伯里
 https://tinysnow.github.io/每日一文/夜空中的木拐 - 从维熙
 https://tinysnow.github.io/每日一文/大坝垮的那天 - 詹姆斯 · 瑟伯
+https://tinysnow.github.io/每日一文/大欲 - 冯唐
 https://tinysnow.github.io/每日一文/大胡子与我 - 三毛
 https://tinysnow.github.io/每日一文/天上落下来的一片叶子 - 安徒生
 https://tinysnow.github.io/每日一文/天堂之门 - 马克

@@ -428,6 +429,7 @@ https://tinysnow.github.io/技术/其他资料/设计模式极简笔记
 https://tinysnow.github.io/技术/其他资料/软件知识补充
 https://tinysnow.github.io/技术/其他资料/重装系统 8-7
 https://tinysnow.github.io/技术/其他资料/重装系统知识
+https://tinysnow.github.io/技术/实践记录/DocSearch 搜索集成
 https://tinysnow.github.io/技术/实践记录/ElasticSearch启用
 https://tinysnow.github.io/技术/实践记录/Logstash同步MySQL数据到ElasticSearch
 https://tinysnow.github.io/技术/实践记录/Mdbook 排版混乱
```

## 指南模板.md

```diff

@@ -1,17 +1,17 @@
-# 指南模板
-
-## 复习
-
-## 正文
-
-## 小结
-
-### 知识点
-
-### 参考资料
-
-### 思考题答案（仅供参考）
-
-## 协议
-
+# 指南模板
+
+## 复习
+
+## 正文
+
+## 小结
+
+### 知识点
+
+### 参考资料
+
+### 思考题答案（仅供参考）
+
+## 协议
+
 本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
\ No newline at end of file
```

## 第一章：计算机的历史.md

```diff

@@ -1,36 +1,36 @@
-# 第一章：计算机的历史
-
-## 正文
-
-　　摒弃教材，来站在发明计算机的人的视角，考察为什么计算机会诞生。
-
-**思考题**
-
-> 　　你是一个工程师，接到了一个任务：要求在两天之内计算十万个形如 2x+3=7 这样的方程，并返回结果，让上级进行下一步数据处理。你此时会有什么愿望？
-
-　　当我们进行冗余繁琐的计算操作，我们迫切希望有一个东西，来帮助我们快速解决这些计算，将自己从枯燥的工作中解放出来。
-
-　　于是计算机诞生。
-
-　　**懒是人类进步的第一动力。**
-
-　　接下来，需要将其实现：需要研究它的组成和需要，以达到我们想要的计算功能。
-
-## 小结
-
-### 知识点
-
-- 计算机诞生的原因
-
-### 参考资料
-
-1. [第一代电子计算机](https://baike.baidu.com/item/%E7%AC%AC%E4%B8%80%E4%BB%A3%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/1430548)：美国国防部用它来进行弹道计算。
-
-### 思考题答案（仅供参考）
-
-需要许多能够达到要求的人帮助进行计算（不太现实），或是有一台机器能批量进行计算（可能现实一点）。
-
-## 协议
-
-本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
-
+# 第一章：计算机的历史
+
+## 正文
+
+　　摒弃教材，来站在发明计算机的人的视角，考察为什么计算机会诞生。
+
+**思考题**
+
+> 　　你是一个工程师，接到了一个任务：要求在两天之内计算十万个形如 2x+3=7 这样的方程，并返回结果，让上级进行下一步数据处理。你此时会有什么愿望？
+
+　　当我们进行冗余繁琐的计算操作，我们迫切希望有一个东西，来帮助我们快速解决这些计算，将自己从枯燥的工作中解放出来。
+
+　　于是计算机诞生。
+
+　　**懒是人类进步的第一动力。**
+
+　　接下来，需要将其实现：需要研究它的组成和需要，以达到我们想要的计算功能。
+
+## 小结
+
+### 知识点
+
+- 计算机诞生的原因
+
+### 参考资料
+
+1. [第一代电子计算机](https://baike.baidu.com/item/%E7%AC%AC%E4%B8%80%E4%BB%A3%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/1430548)：美国国防部用它来进行弹道计算。
+
+### 思考题答案（仅供参考）
+
+需要许多能够达到要求的人帮助进行计算（不太现实），或是有一台机器能批量进行计算（可能现实一点）。
+
+## 协议
+
+本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
+
```

## 第三章：简单逻辑门.md

```diff

@@ -1,180 +1,180 @@
-# 第三章：简单逻辑门
-
-## 复习
-
-- 第一章：希望造出一台计算机。
-- 第二章：这台计算机需要供能，输入，输出和处理过程。
-
-## 正文
-
-　　第二章末尾本应详细介绍冯·诺伊曼体系结构中的运算器和控制器，但此处暂缓，从第三章开始实现后，自然会理解这个结构，前两章为理论基础。既然要造计算机，肯定需要先能计算简单加减法。
-
-### 基础材料
-
-　　手头拥有的最基本材料为：**电和晶体管**（也可以使用电子管，但技术旧且效率低）。由第二章可知，此计算机采用二进制，与数学中布尔代数吻合。布尔代数为二进制信息表示和计算提供有力的数学支撑。
-
-　　布尔代数有三种基本操作：and，or，not，分别是与门，或门，非门。其真值表如下表所示：
-
-- 与门（输入均为 1 时才为 1，只要有 0 即为 0，“同真才真，其余均假”）
-
-| 输入 A | 输入 B | 输出 Y |
-| :----: | :----: | :----: |
-| 0      | 0      | 0      |
-| 0      | 1      | 0      |
-| 1      | 0      | 0      |
-| 1      | 1      | 1      |
-
-- 或门（输入只要有 1 就为 1，全为 0 即为 0，“有真就真，全假才假”）
-
-| 输入 A | 输入 B | 输出 Y |
-| :----: | :----: | :----: |
-| 0      | 0      | 0      |
-| 0      | 1      | 1      |
-| 1      | 0      | 1      |
-| 1      | 1      | 1      |
-
-- 非门（也称反相器，输入为 1 时输出为 0，输入为 0 时输出为 1，“真假对调”）
-
-| 输入 | 输出 |
-| :--: | :--: |
-| 0    | 1    |
-| 1    | 0    |
-
-　　需要说明的是：**与或非三种门，并不能直接获得**，需要用晶体管搭建。但由于晶体管电路太过复杂，超出了本指南范围，本指南只将浅显解释附在其后，读者感兴趣可以自行阅读。
-
-　　为简化说明，本指南 **认为与或非三门可以直接获得。**
-
-　　由基础三门还可构成稍复杂一点的逻辑门：nand（not and 之缩写），nor（not or 之缩写），分别是与非门，或非门。其结果就是与门、非门的结果取反。
-
-- 与非和或非
-
-| 输入 A | 输入 B | and 输出 | nand 输出 | or 输出 | nor 输出 |
-| :----: | :----: | :------: | :-------: | :-----: | :------: |
-|   0    |   0    |    0     |     1     |    0    |    1     |
-|   0    |   1    |    0     |     1     |    1    |    0     |
-|   1    |   0    |    0     |     1     |    1    |    0     |
-|   1    |   1    |    1     |     0     |    1    |    0     |
-
-　　注意，nand 和 nor 两门因自身函数完备性，均可构成基础三门。所以一台计算机可以只由 nand 门或 nor 门构成。
-
-### 半加器
-
-　　接下来尝试计算一位加法（输出 Y 的括号为可能的进位）：
-
-| 输入 A | 输入 B | 输出 Y |
-| :----: | :----: | :----: |
-| 0      | 0      | (0)0   |
-| 0      | 1      | (0)1   |
-| 1      | 0      | (0)1   |
-| 1      | 1      | (1)0   |
-
-　　暂时不管进位，可以观察到：输入相同，结果为 0；输入不同，结果为 1。这种逻辑在以后也很常见，专门有个名字：异或门（xor）。
-
-　　异或门电路可以使用基础三门搭建，方案也很多。总体来讲，用的逻辑门越少，开销越少，效率越高。下面两种设计方案中，很明显，第一种方案要好。
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/nand-xor.png)
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/overzicht-xor.png)
-
-　　接下来处理棘手的进位问题：
-
-　　再次观察，只有当输入均为 1 时才会出现进位，其他情况可以视为进位为 0。容易发现，此逻辑和与门相同：只有输入均为 1 时才为 1。
-
-　　**综上所述，二进制的一位加法器（带进位）可以用一个异或门加上一个与门表示。** 将输入输出引脚分列两边，中间加上逻辑门，可以获得一个一位加法器。
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/half-adder.png)
-
-　　上述一位加法器也称**半加器**。
-
-### 加法器（全加器）
-
-　　来看一个例子，为简化问题，此处数据设为 4 位：计算 0011 + 1001。拆解为 4 个子问题，逐位相加，从左开始：0 + 1，0 + 0，1 + 0，1 + 1。可以观察到这四个问题可以用 4 个半加器解决。但是同时观察到，最后的子问题 1 + 1 产生了进位，所以还需要加上进位。
-
-　　加上进位是个麻烦事。为了之后方便，可以将进位也直接纳入半加器电路，成为 3 输入 2 输出的一个全加器芯片。如图：
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/adder.png)
-
-　　针对此例子可以画出如下电路图：
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/0011+1001.png)
-
-　　将问题泛化：计算 abcd + efgh（一个字母代表一个比特位）。产生 4 个子问题：a + e，b + f，c + g，d + h。因为不知道哪个问题会产生进位，所以均需要加上进位，如图：
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/abcd+efgh.png)
-
-　　如果需要计算 8 位，将半加器扩展成 8 位的样子即可，16、32、64 位同理。
-
-　　如果最高位（即二进制最左边的那一位）产生进位，代表超出了此计算机的数据范围。这里简单丢弃，后续再处理。
-
-### 效率？
-
-　　需要说明的是，将全加器直接串联起来构成的串行进位加法器（也称行波进位加法器），**尤其懒惰和低效**。现代电子所用的加法器，经过优化，速度更快。**但无论如何，我们已经拥有加法器了。**
-
-　　**本指南侧重如何构成加法器**，不涉及加法器的优化，所以之后提到加法器时，默认已经过优化，效率比此章设计的加法器要高。
-
-**思考题**
-
-> 　　由于进位未知但不可缺少，每个全加器都要等待低位的进位，所以效率极低。
->
-> 　　如果每个全加器耗时 0.1 秒，那么 8 位将耗时 0.8 秒。而现代 PC 基本都是 64 位，意味着做一次加法需要 6.4 秒。
->
-> 　　有什么办法能优化这种速度吗？
-
-## 补充
-
-　　符号说明：
-
-- <u>NMOS **高于** 阈值电压导通，**低于** 阈值电压不导通</u>
-- <u>PMOS 则相反</u>
-- <u>V<sub>dd</sub> 为供电电压，恒为 1</u>
-- <u>GND/V<sub>ss</sub> 为接地电压，恒为 0</u>
-- <u>接入端 A 和 B 为接入电压，可高可低，高于阈值电压为 1，低于阈值电压为 0</u>
-
-　　CMOS（互补式金属氧化物半导体）晶体管搭建基础逻辑门的电路图：
-
-- 非门（反相器）
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-inverter.png)
-
-- 与非门
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-nand.png)
-
-- 与门（可以看出实际上就是 nand + not 两模块构成）
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-add.png)
-
-- 或门（与上同理，由 nor + not 构成）
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-or.png)
-
-## 小结
-
-### 知识点
-
-- 与门
-- 或门
-- 非门
-- 半加器
-- 全加器（加法器）
-
-### 参考资料
-
-1. [晶体管](https://zh.wikipedia.org/wiki/晶体管)：现代几乎所有电子设备的基石。
-2. [函数完备性](https://zh.wikipedia.org/zh-hans/完备性)
-3. [超前进位加法器](https://zh.wikipedia.org/wiki/加法器#超前进位加法器)：优化后的加法器，也有缺陷。
-
-### 推荐
-
-1. [MOSFET 快速入门](https://www.bilibili.com/video/BV1nL411x7jH/)
-2. [逻辑门](https://www.bilibili.com/video/BV18M4y137Cr/)
-3. [串行进位加法器](https://www.bilibili.com/video/BV1aQ4y1v7QP/)
-4. [并行进位加法器](https://www.bilibili.com/video/BV1aL41177Si/)
-
-### 思考题答案（仅供参考）
-
-　　可以使用超前进位加法器（也称并行进位加法器）。分析依赖关系之后，可以将进位从串联改为并联，能一定程度上提高效率。但当规模特别大时，此加法器会导致晶体管或逻辑门的数量指数级上升。需要数字电路知识。
-
-## 协议
-
+# 第三章：简单逻辑门
+
+## 复习
+
+- 第一章：希望造出一台计算机。
+- 第二章：这台计算机需要供能，输入，输出和处理过程。
+
+## 正文
+
+　　第二章末尾本应详细介绍冯·诺伊曼体系结构中的运算器和控制器，但此处暂缓，从第三章开始实现后，自然会理解这个结构，前两章为理论基础。既然要造计算机，肯定需要先能计算简单加减法。
+
+### 基础材料
+
+　　手头拥有的最基本材料为：**电和晶体管**（也可以使用电子管，但技术旧且效率低）。由第二章可知，此计算机采用二进制，与数学中布尔代数吻合。布尔代数为二进制信息表示和计算提供有力的数学支撑。
+
+　　布尔代数有三种基本操作：and，or，not，分别是与门，或门，非门。其真值表如下表所示：
+
+- 与门（输入均为 1 时才为 1，只要有 0 即为 0，“同真才真，其余均假”）
+
+| 输入 A | 输入 B | 输出 Y |
+| :----: | :----: | :----: |
+| 0      | 0      | 0      |
+| 0      | 1      | 0      |
+| 1      | 0      | 0      |
+| 1      | 1      | 1      |
+
+- 或门（输入只要有 1 就为 1，全为 0 即为 0，“有真就真，全假才假”）
+
+| 输入 A | 输入 B | 输出 Y |
+| :----: | :----: | :----: |
+| 0      | 0      | 0      |
+| 0      | 1      | 1      |
+| 1      | 0      | 1      |
+| 1      | 1      | 1      |
+
+- 非门（也称反相器，输入为 1 时输出为 0，输入为 0 时输出为 1，“真假对调”）
+
+| 输入 | 输出 |
+| :--: | :--: |
+| 0    | 1    |
+| 1    | 0    |
+
+　　需要说明的是：**与或非三种门，并不能直接获得**，需要用晶体管搭建。但由于晶体管电路太过复杂，超出了本指南范围，本指南只将浅显解释附在其后，读者感兴趣可以自行阅读。
+
+　　为简化说明，本指南 **认为与或非三门可以直接获得。**
+
+　　由基础三门还可构成稍复杂一点的逻辑门：nand（not and 之缩写），nor（not or 之缩写），分别是与非门，或非门。其结果就是与门、非门的结果取反。
+
+- 与非和或非
+
+| 输入 A | 输入 B | and 输出 | nand 输出 | or 输出 | nor 输出 |
+| :----: | :----: | :------: | :-------: | :-----: | :------: |
+|   0    |   0    |    0     |     1     |    0    |    1     |
+|   0    |   1    |    0     |     1     |    1    |    0     |
+|   1    |   0    |    0     |     1     |    1    |    0     |
+|   1    |   1    |    1     |     0     |    1    |    0     |
+
+　　注意，nand 和 nor 两门因自身函数完备性，均可构成基础三门。所以一台计算机可以只由 nand 门或 nor 门构成。
+
+### 半加器
+
+　　接下来尝试计算一位加法（输出 Y 的括号为可能的进位）：
+
+| 输入 A | 输入 B | 输出 Y |
+| :----: | :----: | :----: |
+| 0      | 0      | (0)0   |
+| 0      | 1      | (0)1   |
+| 1      | 0      | (0)1   |
+| 1      | 1      | (1)0   |
+
+　　暂时不管进位，可以观察到：输入相同，结果为 0；输入不同，结果为 1。这种逻辑在以后也很常见，专门有个名字：异或门（xor）。
+
+　　异或门电路可以使用基础三门搭建，方案也很多。总体来讲，用的逻辑门越少，开销越少，效率越高。下面两种设计方案中，很明显，第一种方案要好。
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/nand-xor.png)
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/overzicht-xor.png)
+
+　　接下来处理棘手的进位问题：
+
+　　再次观察，只有当输入均为 1 时才会出现进位，其他情况可以视为进位为 0。容易发现，此逻辑和与门相同：只有输入均为 1 时才为 1。
+
+　　**综上所述，二进制的一位加法器（带进位）可以用一个异或门加上一个与门表示。** 将输入输出引脚分列两边，中间加上逻辑门，可以获得一个一位加法器。
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/half-adder.png)
+
+　　上述一位加法器也称**半加器**。
+
+### 加法器（全加器）
+
+　　来看一个例子，为简化问题，此处数据设为 4 位：计算 0011 + 1001。拆解为 4 个子问题，逐位相加，从左开始：0 + 1，0 + 0，1 + 0，1 + 1。可以观察到这四个问题可以用 4 个半加器解决。但是同时观察到，最后的子问题 1 + 1 产生了进位，所以还需要加上进位。
+
+　　加上进位是个麻烦事。为了之后方便，可以将进位也直接纳入半加器电路，成为 3 输入 2 输出的一个全加器芯片。如图：
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/adder.png)
+
+　　针对此例子可以画出如下电路图：
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/0011+1001.png)
+
+　　将问题泛化：计算 abcd + efgh（一个字母代表一个比特位）。产生 4 个子问题：a + e，b + f，c + g，d + h。因为不知道哪个问题会产生进位，所以均需要加上进位，如图：
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/abcd+efgh.png)
+
+　　如果需要计算 8 位，将半加器扩展成 8 位的样子即可，16、32、64 位同理。
+
+　　如果最高位（即二进制最左边的那一位）产生进位，代表超出了此计算机的数据范围。这里简单丢弃，后续再处理。
+
+### 效率？
+
+　　需要说明的是，将全加器直接串联起来构成的串行进位加法器（也称行波进位加法器），**尤其懒惰和低效**。现代电子所用的加法器，经过优化，速度更快。**但无论如何，我们已经拥有加法器了。**
+
+　　**本指南侧重如何构成加法器**，不涉及加法器的优化，所以之后提到加法器时，默认已经过优化，效率比此章设计的加法器要高。
+
+**思考题**
+
+> 　　由于进位未知但不可缺少，每个全加器都要等待低位的进位，所以效率极低。
+>
+> 　　如果每个全加器耗时 0.1 秒，那么 8 位将耗时 0.8 秒。而现代 PC 基本都是 64 位，意味着做一次加法需要 6.4 秒。
+>
+> 　　有什么办法能优化这种速度吗？
+
+## 补充
+
+　　符号说明：
+
+- <u>NMOS **高于** 阈值电压导通，**低于** 阈值电压不导通</u>
+- <u>PMOS 则相反</u>
+- <u>V<sub>dd</sub> 为供电电压，恒为 1</u>
+- <u>GND/V<sub>ss</sub> 为接地电压，恒为 0</u>
+- <u>接入端 A 和 B 为接入电压，可高可低，高于阈值电压为 1，低于阈值电压为 0</u>
+
+　　CMOS（互补式金属氧化物半导体）晶体管搭建基础逻辑门的电路图：
+
+- 非门（反相器）
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-inverter.png)
+
+- 与非门
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-nand.png)
+
+- 与门（可以看出实际上就是 nand + not 两模块构成）
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-add.png)
+
+- 或门（与上同理，由 nor + not 构成）
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-3/cmos-or.png)
+
+## 小结
+
+### 知识点
+
+- 与门
+- 或门
+- 非门
+- 半加器
+- 全加器（加法器）
+
+### 参考资料
+
+1. [晶体管](https://zh.wikipedia.org/wiki/晶体管)：现代几乎所有电子设备的基石。
+2. [函数完备性](https://zh.wikipedia.org/zh-hans/完备性)
+3. [超前进位加法器](https://zh.wikipedia.org/wiki/加法器#超前进位加法器)：优化后的加法器，也有缺陷。
+
+### 推荐
+
+1. [MOSFET 快速入门](https://www.bilibili.com/video/BV1nL411x7jH/)
+2. [逻辑门](https://www.bilibili.com/video/BV18M4y137Cr/)
+3. [串行进位加法器](https://www.bilibili.com/video/BV1aQ4y1v7QP/)
+4. [并行进位加法器](https://www.bilibili.com/video/BV1aL41177Si/)
+
+### 思考题答案（仅供参考）
+
+　　可以使用超前进位加法器（也称并行进位加法器）。分析依赖关系之后，可以将进位从串联改为并联，能一定程度上提高效率。但当规模特别大时，此加法器会导致晶体管或逻辑门的数量指数级上升。需要数字电路知识。
+
+## 协议
+
 本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
\ No newline at end of file
```

## 第二章：计算机的构成.md

```diff

@@ -1,164 +1,164 @@
-# 第二章：计算机的构成
-
-## 复习
-
-- 第一章：需要一台计算机，在研究其组成的方向上进行努力。
-
-## 正文
-
-### 供能
-
-　　首先，要使机器工作：需要供能。目前最**容易获取**和**广泛运用**的能源：电能。
-
-- 需要供电（能源）
-
-### 处理
-
-　　其次，计算，同处理事情的流程一样，需要：适用前提，已知条件和结果。由此，抽象出以下三点：
-
-- 可计算性（适用前提）
-- 输入数据（已知条件）
-- 输出结果（结果结论）
-
-![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/flow-calculatable.webp)
-
-### 内部表示
-
-　　最后，考虑计算机内部**计算处理**的事情：
-
-- 如何处理与计算机的交互？
-- 信息和数据该怎么表示？
-- 处理时会不会有中间结果，需不需要暂时保留？
-
-#### 交互处理
-
-　　最初的计算机，只希望能快速计算。所以此处将问题最简化：能够输入数据就行。复杂交互处理不在考虑范围之内。
-
-　　<u>由于采用电能，所以最终一切都需要用电信号表示。电信号目前只能分为两种：通电，不通电。</u>
-
-　　*我们需要区别这两种状态，并且，是在计算机一直供电的情况下，让计算机识别输入信号。*
-
-　　**阻挡**是一个办法。
-
-　　最初的计算机科学家们，想到用纸带打孔。有孔洞，类似开关，电路接通，通电。没有孔洞，电路受阻，不通电。如下图：
-
-![paper_cut_off](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/paper-cut-off.webp)
-
-　　这就是最原始的方法，需要程序员做大量的打孔操作，让机器识别。
-
-#### 数据表示
-
-　　由于[交互处理](#交互处理)的前提，需要将所有信息都用通电和不通电表示。
-
-**假设**
-
-> 1. 通电表示 a，不通电表示 b。那其他字母怎么办呢？行不通。
-> 2. 通电表示 1，不通电表示 0。那其他数字怎么办呢？似乎可以。
-
-　　玛雅人采用 20 进制；我们日常使用 10 进制；有些单位（一打）使用 12 进制。
-
-　　那么是否可以采用 2 进制？逢 2 进 1，将其他数字表示出来？
-
-| 二进制 | 十进制 | 二进制 | 十进制 |
-| :----: | :----: | :----: | :----: |
-| 0000   | 0      | 0101   | 5      |
-| 0001   | 1      | 0110   | 6      |
-| 0010   | 2      | 0111   | 7      |
-| 0011   | 3      | 1000   | 8      |
-| 0100   | 4      | 1001   | 9      |
-
-　　回到假设 1：如果需要表示字母和其他符号，怎么办？进制只能表示数字。
-
-　　既然数字这个界限不能打破，那么是否可以抽一部分数字出来，专门用来表示其他字母或者符号？美国想出了这个方法，由此诞生 ASCII 码。详细了解请见参考资料。
-
-**思考题 1**
-
-> 　　这个方法似乎也有些问题。例如，ASCII 码中规定 0100 0001（二进制，转换为十进制为 65）表示字母 A ，那真要表示 65 怎么办？以及，上述的假设 1，其他字母真的就表示不出来吗？
-
-　　这个方法可以解决问题。虽不完美，但目前没有想出更好的解决办法，就这样先用着。
-
-　　为了方便计算机学界交流，为这些知识起个术语：
-
-- 一个二进制的 0 或 1 称为 bit，比特，用 b 表示
-- 8 个二进制的 0 或 1 成为 Byte，字节，用 B 表示
-  - 8 是人为规定的，二进制表示一个数据会非常长，表示 0-9 都需要 4 个 bit
-
-#### 中间结果
-
-　　毋庸置疑，需要保存中间结果。原因：
-
-- 我们希望一次性将所有计算任务都输入进去，等待计算机完成。而非计算一次输入一次。
-- 计算较为复杂时，中间结果不可丢弃，否则后续计算将出现错误。
-
-　　我们需要有某个东西，能够存放数据，即存放中间结果的二进制表示。我们姑且称为“存储器”。
-
-### 体系结构
-
-　　处理完三个棘手的问题，得出新的结论，一台计算机需要有：
-
-- 输入设备（详见[处理](#处理)）
-- 输出设备（详见[处理](#处理)）
-- 存储器（详见[中间结果](#中间结果)）
-- 核心的计算单元（核心功能）
-
-　　上述体系结构，被称为冯·诺依曼体系结构，至今仍在沿用（**人类所有知识都来源于好奇心和解决问题**）。如图所示：
-
-![Von_Neumann_Architecture](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/von_neumann-architecture.webp)
-
-**思考题 2**
-
-> 　　如果未来发生了一场能源革命，发现一种新能源：另能。另能激活时，有 A、B、C 三种不同的形态，均可导通另路（类似电路）。
->
-> 　　那么计算机是否会发生革命？如果你是另能计算机设计者，会采用几进制？
->
-> 　　最后，冯·诺伊曼体系结构是否会随着技术发展而打破？
-
-## 小结
-
-### 知识点
-
-　　一个核心：计算机如何构成。达成这个目的，需要：
-
-- 能源
-- 输入
-- 输出
-- 计算处理
-  - 二进制和 ASCII 码
-    - 比特(bit)
-    - 字节(Byte)
-  - 存储器
-  - 计算单元
-- 冯·诺伊曼体系结构
-
-### 参考资料
-
-1. [计算理论](https://zh.m.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA)：一个问题是否可以计算。偏数学领域，不在讨论范围之内。
-
-2. [ASCII 码](https://zh.m.wikipedia.org/zh-cn/ASCII)：American Standard Code for Information Interchange，美国信息交换标准代码。
-
-3. [二进制](https://zh.m.wikipedia.org/zh-cn/%E4%BA%8C%E8%BF%9B%E5%88%B6)：数据的表示方法。
-
-4. [冯·诺依曼体系结构](https://zh.wikipedia.org/zh-cn/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)：现代电子计算机的基本体系结构。
-
-5. [Сетунь](https://zh.m.wikipedia.org/zh-cn/%D0%A1%D0%B5%D1%82%D1%83%D0%BD%D1%8C)：苏联诞生的三进制计算机。
-
-
-### 思考题答案（仅供参考）
-
-#### 思考题 1
-
-  1. 65 和 A 的表示原理相同。A 是一个字符，65 是 6 和 5 两个字符。表示 65，即表示 6 的 ASCII 代码，然后跟上 5 的 ASCII 代码：<u>0011 0110</u>(6) <u>0011 0101</u>(5)。注意：此处只讨论这两个字节用于显示，而非用于计算或表示指令等。
-
-  2. 可以用 a 和 b 进行进制排列。如 a 表示 a，b 表示 b，ba 表示 c，bb 表示 d，baa 表示 e，bab 表示 f，bba 表示 g 等。但此方法实质一样，并且违背现存符号体系，不采用。如果不采用进制排列，因元符号（不可再分的符号单位）只有通电与不通电，所以只能表示两个信息。目前没有突破采用进制以外的信息表示法（符号少，只能依靠排列增加信息数量）。
-
-     **请注意：此答案 2 并不严谨，但于初学者而言，容易理解且偏差不大。**（苏联曾经诞生过三进制计算机）
-
-#### 思考题 2
-
-1. 会。因为元符号数量从 2 个增长为 4 个。
-2. 4 进制。未导通态 1 个加上导通态 3 个，共 4 个。可以表示为 0-3，此时每 1 位（四进制）可以表示 2 个比特位（二进制）。
-3. 科学和技术一直在进步。假设，某一天技术强大到所有输入和输出均可一个设备完成，则该体系也会随之淘汰。
-
-## 协议
-
+# 第二章：计算机的构成
+
+## 复习
+
+- 第一章：需要一台计算机，在研究其组成的方向上进行努力。
+
+## 正文
+
+### 供能
+
+　　首先，要使机器工作：需要供能。目前最**容易获取**和**广泛运用**的能源：电能。
+
+- 需要供电（能源）
+
+### 处理
+
+　　其次，计算，同处理事情的流程一样，需要：适用前提，已知条件和结果。由此，抽象出以下三点：
+
+- 可计算性（适用前提）
+- 输入数据（已知条件）
+- 输出结果（结果结论）
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/flow-calculatable.webp)
+
+### 内部表示
+
+　　最后，考虑计算机内部**计算处理**的事情：
+
+- 如何处理与计算机的交互？
+- 信息和数据该怎么表示？
+- 处理时会不会有中间结果，需不需要暂时保留？
+
+#### 交互处理
+
+　　最初的计算机，只希望能快速计算。所以此处将问题最简化：能够输入数据就行。复杂交互处理不在考虑范围之内。
+
+　　<u>由于采用电能，所以最终一切都需要用电信号表示。电信号目前只能分为两种：通电，不通电。</u>
+
+　　*我们需要区别这两种状态，并且，是在计算机一直供电的情况下，让计算机识别输入信号。*
+
+　　**阻挡**是一个办法。
+
+　　最初的计算机科学家们，想到用纸带打孔。有孔洞，类似开关，电路接通，通电。没有孔洞，电路受阻，不通电。如下图：
+
+![paper_cut_off](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/paper-cut-off.webp)
+
+　　这就是最原始的方法，需要程序员做大量的打孔操作，让机器识别。
+
+#### 数据表示
+
+　　由于[交互处理](#交互处理)的前提，需要将所有信息都用通电和不通电表示。
+
+**假设**
+
+> 1. 通电表示 a，不通电表示 b。那其他字母怎么办呢？行不通。
+> 2. 通电表示 1，不通电表示 0。那其他数字怎么办呢？似乎可以。
+
+　　玛雅人采用 20 进制；我们日常使用 10 进制；有些单位（一打）使用 12 进制。
+
+　　那么是否可以采用 2 进制？逢 2 进 1，将其他数字表示出来？
+
+| 二进制 | 十进制 | 二进制 | 十进制 |
+| :----: | :----: | :----: | :----: |
+| 0000   | 0      | 0101   | 5      |
+| 0001   | 1      | 0110   | 6      |
+| 0010   | 2      | 0111   | 7      |
+| 0011   | 3      | 1000   | 8      |
+| 0100   | 4      | 1001   | 9      |
+
+　　回到假设 1：如果需要表示字母和其他符号，怎么办？进制只能表示数字。
+
+　　既然数字这个界限不能打破，那么是否可以抽一部分数字出来，专门用来表示其他字母或者符号？美国想出了这个方法，由此诞生 ASCII 码。详细了解请见参考资料。
+
+**思考题 1**
+
+> 　　这个方法似乎也有些问题。例如，ASCII 码中规定 0100 0001（二进制，转换为十进制为 65）表示字母 A ，那真要表示 65 怎么办？以及，上述的假设 1，其他字母真的就表示不出来吗？
+
+　　这个方法可以解决问题。虽不完美，但目前没有想出更好的解决办法，就这样先用着。
+
+　　为了方便计算机学界交流，为这些知识起个术语：
+
+- 一个二进制的 0 或 1 称为 bit，比特，用 b 表示
+- 8 个二进制的 0 或 1 成为 Byte，字节，用 B 表示
+  - 8 是人为规定的，二进制表示一个数据会非常长，表示 0-9 都需要 4 个 bit
+
+#### 中间结果
+
+　　毋庸置疑，需要保存中间结果。原因：
+
+- 我们希望一次性将所有计算任务都输入进去，等待计算机完成。而非计算一次输入一次。
+- 计算较为复杂时，中间结果不可丢弃，否则后续计算将出现错误。
+
+　　我们需要有某个东西，能够存放数据，即存放中间结果的二进制表示。我们姑且称为“存储器”。
+
+### 体系结构
+
+　　处理完三个棘手的问题，得出新的结论，一台计算机需要有：
+
+- 输入设备（详见[处理](#处理)）
+- 输出设备（详见[处理](#处理)）
+- 存储器（详见[中间结果](#中间结果)）
+- 核心的计算单元（核心功能）
+
+　　上述体系结构，被称为冯·诺依曼体系结构，至今仍在沿用（**人类所有知识都来源于好奇心和解决问题**）。如图所示：
+
+![Von_Neumann_Architecture](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-2/von_neumann-architecture.webp)
+
+**思考题 2**
+
+> 　　如果未来发生了一场能源革命，发现一种新能源：另能。另能激活时，有 A、B、C 三种不同的形态，均可导通另路（类似电路）。
+>
+> 　　那么计算机是否会发生革命？如果你是另能计算机设计者，会采用几进制？
+>
+> 　　最后，冯·诺伊曼体系结构是否会随着技术发展而打破？
+
+## 小结
+
+### 知识点
+
+　　一个核心：计算机如何构成。达成这个目的，需要：
+
+- 能源
+- 输入
+- 输出
+- 计算处理
+  - 二进制和 ASCII 码
+    - 比特(bit)
+    - 字节(Byte)
+  - 存储器
+  - 计算单元
+- 冯·诺伊曼体系结构
+
+### 参考资料
+
+1. [计算理论](https://zh.m.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA)：一个问题是否可以计算。偏数学领域，不在讨论范围之内。
+
+2. [ASCII 码](https://zh.m.wikipedia.org/zh-cn/ASCII)：American Standard Code for Information Interchange，美国信息交换标准代码。
+
+3. [二进制](https://zh.m.wikipedia.org/zh-cn/%E4%BA%8C%E8%BF%9B%E5%88%B6)：数据的表示方法。
+
+4. [冯·诺依曼体系结构](https://zh.wikipedia.org/zh-cn/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)：现代电子计算机的基本体系结构。
+
+5. [Сетунь](https://zh.m.wikipedia.org/zh-cn/%D0%A1%D0%B5%D1%82%D1%83%D0%BD%D1%8C)：苏联诞生的三进制计算机。
+
+
+### 思考题答案（仅供参考）
+
+#### 思考题 1
+
+  1. 65 和 A 的表示原理相同。A 是一个字符，65 是 6 和 5 两个字符。表示 65，即表示 6 的 ASCII 代码，然后跟上 5 的 ASCII 代码：<u>0011 0110</u>(6) <u>0011 0101</u>(5)。注意：此处只讨论这两个字节用于显示，而非用于计算或表示指令等。
+
+  2. 可以用 a 和 b 进行进制排列。如 a 表示 a，b 表示 b，ba 表示 c，bb 表示 d，baa 表示 e，bab 表示 f，bba 表示 g 等。但此方法实质一样，并且违背现存符号体系，不采用。如果不采用进制排列，因元符号（不可再分的符号单位）只有通电与不通电，所以只能表示两个信息。目前没有突破采用进制以外的信息表示法（符号少，只能依靠排列增加信息数量）。
+
+     **请注意：此答案 2 并不严谨，但于初学者而言，容易理解且偏差不大。**（苏联曾经诞生过三进制计算机）
+
+#### 思考题 2
+
+1. 会。因为元符号数量从 2 个增长为 4 个。
+2. 4 进制。未导通态 1 个加上导通态 3 个，共 4 个。可以表示为 0-3，此时每 1 位（四进制）可以表示 2 个比特位（二进制）。
+3. 科学和技术一直在进步。假设，某一天技术强大到所有输入和输出均可一个设备完成，则该体系也会随之淘汰。
+
+## 协议
+
 本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
\ No newline at end of file
```

## 第五章：乘法与除法.md

```diff

@@ -38,42 +38,57 @@
 
 　　那就好办了，让一个二进制数，与另一个二进制数的 <u>每一位</u> 相乘，然后进行竖式一样的 <u>移位</u> 操作，最后加在一起就好了。因为补码可以参与运算，所以负数的乘法也解决了，下面就是实现了。
 
-　　相乘，仔细观察可以用 and（与门）解决，那——**移位** 呢？该怎么办？
+　　相乘，仔细观察可以用 and（与门）解决，那—— **移位** 呢？该怎么办？
 
 #### Booth 算法
 
-　　Booth 算法是一种针对二进制补码的乘法算法，可以将时间复杂度降低到 $O(n)$，同时也比逐位相乘更适合硬件实现。
+　　上述逐位相乘有一个问题：
 
-　　Booth 算法的核心思想是：对于二进制补码的每一位，我们可以通过判断它与它前一位的关系，来决定是否进行加减操作。
+　　如果是 M × `0100` 这样就还好，只用加一个数字——因为只要乘数的某一位为 0，结果就必定为 0。所以逐位相乘，结果就是 `0 + M + 0 + 0`，实际上只用加 `M` 这一个数字。
 
-　　以 `1010`<sub>2</sub> × `1101`<sub>2</sub> 为例：
+　　如果是 M × `1111` 这样的呢？就需要加四个数字——`M + M + M + M`。这在乘数位数变多（比如 64 位）的时候，连续的 1 将极为致命，会严重拖慢计算速度。
 
-- 第一步：在乘数最后面补一个 0，得到 `10100`<sub>2</sub>，表示 $2 \times 1010$。
-- 第二步：从右往左，取出两位作为判断基准。判断基准共有三种情况：
-  - `00`：不操作；
-  - `01`：将被乘数减去乘数；
-  - `10`：将被乘数加上乘数。
-- 第三步：将判断基准向左移一位，继续循环判断，直到乘数的所有位都处理完毕。
+　　于是 Booth 算法优化了这一点。Booth 算法的核心思想是：对于 <u>二进制补码</u> 的每一位，我们可以通过判断它与它前一位的关系，来决定是否进行加减操作。
 
-　　具体实现可以看下面的表格：
+　　看不懂？来个实际的：设 X<sub>补码</sub> =  X<sub>s</sub>X<sub>n</sub>X<sub>n-1</sub>...X<sub>1</sub>X<sub>0</sub>, Y<sub>补码</sub> =  Y<sub>s</sub>Y<sub>n</sub>Y<sub>n-1</sub>...Y<sub>1</sub>Y<sub>0</sub>，有 M × `00111000`。
 
-| 被乘数  | 判断基准 | 操作 | 乘数   |
-| ------- | -------- | ---- | ------ |
-| `10100` | `00`     | #    | `1101` |
-| `10100` | `00`     | #    | `1101` |
-| `10100` | `01`     | -    | `1101` |
-| `10100` | `10`     | +    | `1101` |
-| `10101` | `10`     | +    | `1101` |
+　　而 M × `00111000` = M × ( 2<sup>3</sup> + 2<sup>4</sup> + 2<sup>5</sup> ) = M × (`01000000` - `00001000`) =  M × ( 2<sup>6</sup> - 2<sup>3</sup> )。
 
-　　最终结果为 `111110`<sub>2</sub>，转换为十进制为 `62`。
+　　整理一下可以得出：2<sup>6</sup> × M - 2<sup>3</sup> × M，也即，在原乘数 `00111000` 中，<u>`10` 表示连续 1 的开始，对应 - M × 2<sup>3</sup>，`01` 表示连续 1 的结束，对应 M ×  2<sup>6</sup></u>，那么可以得出移位的规则：
+
+| Y<sub>n+1</sub> | Y<sub>n</sub> |                 操作规则                  |
+| :-------------: | :-----------: | :---------------------------------------: |
+|        0        |       0       |              部分积右移一位               |
+|        0        |       1       | 部分积 + X<sub>补码</sub>，部分积右移一位 |
+|        1        |       0       | 部分积 - X<sub>补码</sub>，部分积右移一位 |
+|        1        |       1       |              部分积右移一位               |
+
+- 为什么要右移？
+  - 往上划到逐位相乘的例子，计算部分积的时候，低位往往不受高位的数值影响（看上面的竖式更容易理解）：
+    - 计算完 `0011`，此时部分积为 `0011`，此后最右边的 `1` 不受后面计算的影响。
+    - 计算完 `0011` + `0000#`，此时部分积为 `0011`，此后最右边的 `11` 不受后面计算的影响。
+    - 计算完 `0011` + `0000#` + `0011##`，此时部分积为 `1111`，此后最右边的 `111` 不受后面计算的影响。
+    - 以此类推。
+  - 因为不受高位的影响，所以可以右移将低位挤掉，使部分积与被乘数对齐，这样可以直接计算。
+- 部分积 - X<sub>补码</sub> 怎样计算？
+  - 回忆一下第四章：减法在二进制计算机里的定义是，加上 减数取反后的数值，再加一
+- 为什么移位规则里， `01` 和 `10` 的规则，一个正一个负？
+  - 因为 <u>`10` 表示连续 1 的开始，对应 - M × 2<sup>3</sup>，`01` 表示连续 1 的结束，对应 M ×  2<sup>6</sup></u>
+  - 而上述 2<sup>3</sup> 和 2<sup>6</sup>，已经在移位中解决了，所以只用加减 X<sub>补码</sub>
+
+**思考题 1**
+
+> 　　**对一个数的补码再求补码，等于该数的原码吗？**
 
 ### 移位
 
-　　我们没有介绍过移位，但应该能想到，上面乘法移位最简单的方式，就是在最后一位后面补零，同时丢掉最高位：`0011` 不补零，`0000` 补一个，`0011` 补两个。
+　　我们没有介绍过移位，但应该能想到，上面逐位相乘的移位，最简单的方式，就是在最后一位后面补零，同时丢掉最高位（以上述竖式的中间结果为例）：`0011` 不补零，`0000` 补一个，`0011` 补两个。
+
+　　<u>而在对有符号数进行移位时，特别是右移，最高位需要补上符号位</u> 。也就是说：对 1010 进行右移，结果应该为 1101。
 
-**思考题**
+**思考题 2**
 
-> 　　我们现在只有加法器，应该怎样移位和补零？以及， **设计一个最简单的乘法器，真的需要移位吗？**
+> 　　我们现在只有加法器，应该怎样移位和补位？以及， **设计一个最简单的乘法器，真的需要移位吗？**
 
 ### 除法
 

@@ -87,117 +102,86 @@
 12 - 3 = 9
 9 - 3 = 6
 6 - 3 = 3
+3 - 3 = 0
 ```
 
-　　因此，得到结果 `4`。
+　　因此，得到结果 `4`，也即减去的次数。
 
-　　但这种实现方式效率低下，需要进行多次减法运算。因此，为了提高运算效率，我们通常使用更高效的算法来实现除法。
+　　此实现需要进行多次减法运算，效率低下。为了提高运算效率，我们需要更高效的算法。
 
-#### 短除法
+#### 长除法
 
-　　短除法也是我们平常手算除法的方式：先将被除数的高位和除数对齐，然后用除数去除被除数，得到商和余数，再将余数和下一位对齐，继续除，直到被除数的所有位都处理完毕或者余数为 0。
-
-　　以 `10110`<sub>2</sub> ÷ `101`<sub>2</sub> 为例：
+　　长除法是我们平常手算除法的方式：先将被除数的高位和除数对齐，然后用除数去除被除数，得到商和余数，再将余数和下一位对齐，继续除，直到被除数的所有位都处理完毕或者余数为 0。以 `101101`<sub>2</sub> ÷ `101`<sub>2</sub> 为例：
 
 ```
-      10
-   _______
-101|10110
-    101
-    ---
-    100
+      1001
+    _______
+101)101101
     101
-    ---
-      1
-```
-
-　　上面的表格中，每一行的第一列为商，第二列为余数，第三列为下一位被除数。最终商为 `100`<sub>2</sub>，余数为 `1`<sub>2</sub>。
-
-　　短除法的时间复杂度为 $O(n)$，与位数成正比。但是如果除数的位数较大，短除法的效率会比较低。此时，可以采用更高效的除法算法，如牛顿迭代法、二分法等。
-
-#### 除法的基本算法
-
-　　除法的基本算法是长除法，也叫做列竖式除法。
-
-　　例如，我们要计算 `345 ÷ 67`：
-
+    _______
+       101
+       101
+    _______
+         0
 ```
-     5
-  ------
- 67|345
-    335
-    ---
-     10
-      9
-     ---
-      6
 
-```
+　　短除法的复杂程度与位数成正比。除数位数越大，长除法效率越低。
 
-　　具体步骤如下：
+　　计算机底层可以实现更高效的除法算法（牛顿迭代法、二分法等），但是否实现取决于成本，高效除法比较复杂，此处略去不讲。
 
-1. 将被除数和除数竖列在一起，以个位数为基准。
-2. 将第一个被除数的位与除数进行比较，看能否整除。
-3. 如果能整除，则在商的下一位写入商的一位，否则在商的下一位写入 `0`。
-4. 将除数乘以商的一位，得到一个中间结果。
-5. 将中间结果从被除数中减去，得到新的被除数。
-6. 重复上述步骤，直到被除数小于除数为止，此时商的值即为最终结果。
+　　长除法通常使用移位和减法来实现，也被称为 **位移除法** （向左移位再相减）。
 
-　　长除法的优点是计算精确，适用于小规模的计算。但对于大规模的计算，长除法效率太低，需要更高效的算法。
+## 小结
 
-#### 快速除法
+### 知识点
 
-　　快速除法采用二进制计算的思路，将除法转化为位运算，从而大大提高了计算速度。
+- 乘法
+  - 本质
+  - 逐位相乘
+  - Booth 算法（对逐位相乘的优化）
+- 除法
+  - 本质
+  - 长除法
 
-　　例如，我们要计算 `12 ÷ 3`：
+### 参考资料
 
-```
-12 ÷ 3 = (1100)_2 ÷ (11)_2 = 100
-```
+- [Wikipedia：Booth 算法](https://zh.wikipedia.org/wiki/布斯乘法算法)
+- [Wikipedia：长除法](https://zh.wikipedia.org/wiki/長除法)
+- [Wikipedia：位操作#移位](https://zh.wikipedia.org/wiki/位操作#移位)
+- [BiliBili：计算机怎样计算乘法](https://www.bilibili.com/video/BV1AB4y1p7ax/)
+- [Booth 算法过程具体示例](https://medium.com/@jetnipit54/booth-algorithm-e6b8a6c5b8d)
+- [Booth 算法过程抽象总结](https://xkaneiki.github.io/2019/08/28/Booth算法/)
 
-　　具体步骤如下：
+### 推荐
 
-1. 将被除数和除数转化为二进制数。
-2. 将被除数的每一位（从左往右）与除数相除，得到若干个二进制数。
-3. 对这些二进制数进行相加，得到最终结果。
+- [BiliBili：计算机怎样计算乘法](https://www.bilibili.com/video/BV1AB4y1p7ax/)
+- [Wikipedia：位操作#移位](https://zh.wikipedia.org/wiki/位操作#移位)
 
-　　快速除法的优点是计算速度快，适用于大规模的计算。但需要注意的是，快速除法只适用于整数的除法运算。同时，快速除法可能会导致精度损失，需要进行额外的处理。
+### 思考题答案（仅供参考）
 
-　　除法是指将一个数除以另一个数得到商和余数的过程。在计算机中，除法通常使用移位和减法操作来实现，这被称为 **<u>位移除法</u>**。下面是一个例子：
+#### 思考题 1
 
-- `14 ÷ 3 = 4 余 2`
+　　回想一下，补码究竟是怎样推导出来的——相反数相加为零。所以，对一个数的补码再求补码，其实就是对一个数的相反数再求相反数，其结果必然等于自身。
 
-　　首先将 14 和 3 转换为二进制数 `1110` 和 `0011`。接下来使用下面的算法：
+　　二进制中，特殊在于：
 
-- 将被除数（14）左移一位，得到 `11100`。
-- 如果左移后的结果大于或等于除数（3），则将该结果减去除数，并在商的相应位上置 1。
-- 将被除数左移一位，重复上述步骤，直到被除数小于除数为止。
+- 减法的定义为：加上 该数取反后的数值，再加一
+- 负数的定义为：该数取反后的数值，再加一
 
-　　使用上述算法，可以得到以下结果：
+　　**这两种说法本质上是相同的：- X，可以是 X 的负数，也可以是 0 减去 X。** 有趣的地方在于：
 
-- `1110 ÷ 0011 = 100 余 010`，即 `4 余 2`。
+- 如果我们将 X 按照定义进行两次求补，也即 `~(~X + 1) + 1`，它并不等于 `X + ~1 + 1`
 
-　　在计算机中，左移和减法操作通常使用移位运算符 `<<` 和 `-` 实现，例如：
+#### 思考题 2 
 
-```c
-int a = 14; // 二进制为 1110
-int b = 3; // 二进制为 0011
-int q = 0; // 商的初始值为 0
-int r = a; // 余数的初始值为被除数
+1. 移位可以使用 or 和 xor 门，也可以将输入直接与输出错位相连。错位直接相连肯定比使用逻辑门效率更高，速度更快（图源：Wikipedia）。
 
-while (r >= b) {
-  r = r << 1; // 左移一位
-  q = q << 1; // 左移一位
-  if (r >= b) {
-    r = r - b; // 减去除数
-    q = q + 1; // 商的相应位上置 1
-  }
-}
-```
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-5/shift.png)
 
-　　在上面的代码中，`r`表示余数，初始值为被除数；`q` 表示商的值，初始值为 0。在循环中，首先将余数左移一位，然后判断左移后的结果是否大于或等于除数，如果是，则将余数减去除数，并在商的相应位上置 1。重复上述步骤直到余数小于除数为止，最后得到的商就是 `4`，余数就是 `2`。
+1. 其实最简单的乘法器不需要移位，只需要错位相加，当中错位可以让低位直接输出（图源：BiliBili 硬件茶谈）。
 
-### 总结
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-5/simplest-multiplicator.png)
 
-　　本章介绍了乘法和除法的基本原理，以及在计算机中如何实现乘法和除法运算。乘法通常使用加法和移位操作来实现，而除法通常使用移位和减法操作来实现。在实际编程中，可以使用移位运算符 `<<` 和 `-` 来实现位移除法。
+## 协议
 
+本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
\ No newline at end of file
```

## 第四章：负数与减法.md

```diff

@@ -1,4 +1,4 @@
-# 第四章：负数与减法（WIP）
+# 第四章：负数与减法
 
 ## 复习
 

@@ -83,7 +83,7 @@
 - 因为这个编码本身就是从算式（`2 + (-2) = 0`）中推导出来的， **可以直接参与计算** ，叫做 **补码**。
   - 正数的补码是自身——补码本身就是从相反数的编码中推导出来的。
 
-**思考题**
+**思考题 1**
 
 > 　　有什么便捷方法，能快速计算出补码吗？
 

@@ -99,7 +99,7 @@
   - 本质上是因为有正零（`0000`）和负零（`1000`）的存在，一个零占了两个编码。
   - **原码和原码，原码和反码，反码和反码之间，均不能直接相加。**
 
-**思考题**
+**思考题 2**
 
 > 　　为什么 `1000`<sub>2 进制补码</sub> 是 `-8`<sub>10</sub>？
 

@@ -107,9 +107,13 @@
 
 　　上述可知，减法可以表示为加上负数，而负数又用补码表示：所以将加法器的减数，变成其对应的补码即可。也即 `5` - `2` = `5` + `2 的补码`。
 
-　　而补码又是取反加一，所以输入加法器之前，经过求补模块即可。求补模块 = 取反 + 加一。取反可以让每位都经过一次 not 门，加一可以放置一个加法器固定加上 1。
+　　或者我们也可以说： **减法在二进制计算机里的定义是，加上 减数取反后的数值，再加一。**
 
+　　而补码又是取反加一，所以输入加法器之前，经过求补模块即可。求补模块 = 取反 + 加一，也可以说是减法模块。取反可以让每位都经过一次 not 门，加一可以放置一个加法器固定加上 1。
 
+　　大概就像这样（图源：BiliBili 硬件茶谈）：
+
+![](https://raw.githubusercontent.com/TinySnow/GithubImageHosting/main/blog/technology/cs-teaching/chapter-4/subtraction-module.png)
 
 ## 小结
 

@@ -130,6 +134,13 @@
 
 ### 参考资料
 
+- [有符号数](https://zh.wikipedia.org/wiki/有符號數處理)
+- [计算机怎样计算减法](https://www.bilibili.com/video/BV1fr4y1S7gG/)
+
+### 推荐
+
+- [计算机怎样计算减法](https://www.bilibili.com/video/BV1fr4y1S7gG/)
+
 ### 思考题答案（仅供参考）
 
 #### 思考题 1
```

## 计算机科学极简入门指南.md

```diff

@@ -1,81 +1,81 @@
-# 计算机科学极简入门指南
-
-## 最重要的
-
-阅读本教程，请牢记四句话，以后将反复提到，都很简单。若现在不懂没有关系，感触将随着教程推进越来越深。现阶段，只需要死记硬背，以后会自行理解。
-
-内容如下：
-
-- **懒是人类进步的第一动力。**
-- **在计算机科学里，没有什么问题是加一层解决不了的。**
-- **人类所有知识都来源于好奇心和解决问题。**
-- **所有庞大学科体系，都是一点一点累加起来的，不会一蹴而就，没有学科例外。**
-
-## 写在前面
-
-### 风格
-
-本教程遵循以下风格：
-
-- 极简风格，争取不浪费读者时间
-- [阮一峰中文技术文档写作规范](https://github.com/ruanyf/document-style-guide)（不严格遵守）
-- 具有极强的个人用语风格
-- 用语介于口语和书面语之间，比较通俗
-  - 口语具有亲切感和人情味，但传达效率不高
-  - 书面语使人严肃，但使人感觉抗拒和枯燥
-
-### 理念
-
-- “授人以鱼不如授人以渔”
-- 示例优先，抽象其后，有助理解
-- 兴趣是最好的老师
-- 最好的学习方法是解决问题
-
-### 问题
-
-由于遵循极简风格，所以会诞生以下问题：
-
-- 本教程只能起到引导作用，而非百科全书，旨在**自顶向下**为读者带来一个全局的观念
-  - 请不要抱有看完这系列教程后能成为技术顶尖分子的幻想
-- 本教程学习方法和知识点各占一半
-  - 具体各知识点，若有兴趣，可以按照此教程学习方法寻找资料学习
-
-### 适用人群
-
-- 零基础
-  - 请务必阅读整个教程
-- 非零基础技术人员
-  - 请跳读或选读以提高效率
-
-### 阅读要求
-
-只有一个：
-
-**每章节或知识点后有相应的，精挑细选的 1-2 道思考题，请务必认真思考**
-
-- 思考题经过精心挑选
-- 目的在于希望读者能让知识点得到运用
-- 除此之外：因人脑不适合记忆孤立的知识点，希望能通过思考题将知识点连接成知识网络
-
-### 勘误说明
-
-因笔者知识水平和技术能力有限，若有勘误，尽请斧正，提交 Pull Request。
-
-诚挚希望能得到各位技术人员的交流，并非客套。
-
-### 联系方式
-
-Email：[lo.tinysnow.ol@outlook.com](mailto:lo.tinysnow.ol@outlook.com)
-
-Telegram：[http://t.me/TinySnow](http://t.me/TinySnow)
-
-Github：[TinySnow](https://github.com/TinySnow)
-
-## 协议
-
-本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
-
-
-
-
-
+# 计算机科学极简入门指南
+
+## 最重要的
+
+阅读本教程，请牢记四句话，以后将反复提到，都很简单。若现在不懂没有关系，感触将随着教程推进越来越深。现阶段，只需要死记硬背，以后会自行理解。
+
+内容如下：
+
+- **懒是人类进步的第一动力。**
+- **在计算机科学里，没有什么问题是加一层解决不了的。**
+- **人类所有知识都来源于好奇心和解决问题。**
+- **所有庞大学科体系，都是一点一点累加起来的，不会一蹴而就，没有学科例外。**
+
+## 写在前面
+
+### 风格
+
+本教程遵循以下风格：
+
+- 极简风格，争取不浪费读者时间
+- [阮一峰中文技术文档写作规范](https://github.com/ruanyf/document-style-guide)（不严格遵守）
+- 具有极强的个人用语风格
+- 用语介于口语和书面语之间，比较通俗
+  - 口语具有亲切感和人情味，但传达效率不高
+  - 书面语使人严肃，但使人感觉抗拒和枯燥
+
+### 理念
+
+- “授人以鱼不如授人以渔”
+- 示例优先，抽象其后，有助理解
+- 兴趣是最好的老师
+- 最好的学习方法是解决问题
+
+### 问题
+
+由于遵循极简风格，所以会诞生以下问题：
+
+- 本教程只能起到引导作用，而非百科全书，旨在**自顶向下**为读者带来一个全局的观念
+  - 请不要抱有看完这系列教程后能成为技术顶尖分子的幻想
+- 本教程学习方法和知识点各占一半
+  - 具体各知识点，若有兴趣，可以按照此教程学习方法寻找资料学习
+
+### 适用人群
+
+- 零基础
+  - 请务必阅读整个教程
+- 非零基础技术人员
+  - 请跳读或选读以提高效率
+
+### 阅读要求
+
+只有一个：
+
+**每章节或知识点后有相应的，精挑细选的 1-2 道思考题，请务必认真思考**
+
+- 思考题经过精心挑选
+- 目的在于希望读者能让知识点得到运用
+- 除此之外：因人脑不适合记忆孤立的知识点，希望能通过思考题将知识点连接成知识网络
+
+### 勘误说明
+
+因笔者知识水平和技术能力有限，若有勘误，尽请斧正，提交 Pull Request。
+
+诚挚希望能得到各位技术人员的交流，并非客套。
+
+### 联系方式
+
+Email：[lo.tinysnow.ol@outlook.com](mailto:lo.tinysnow.ol@outlook.com)
+
+Telegram：[http://t.me/TinySnow](http://t.me/TinySnow)
+
+Github：[TinySnow](https://github.com/TinySnow)
+
+## 协议
+
+本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
+
+
+
+
+
```
