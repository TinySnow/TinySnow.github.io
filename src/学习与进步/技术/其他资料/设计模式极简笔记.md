# 设计模式极简笔记

## 设计原则

1. 单一职责原则
  - 只做一件事
2. 开闭原则
  - 对扩展开放，对修改关闭
3. 里氏代换原则
  - 能用父类，肯定能透明地使用子类
4. 依赖倒转原则
  - 抽象不应该依赖细节，细节应该依赖抽象
  - 应该面向接口编程，而不是针对实现编程
5. 接口隔离原则
  - 使用专用接口，而非总接口
  - 客户端不应该依赖它不需要的接口
6. 合成复用原则
  - 尽量使用对象组合，而不是继承来达到复用效果
7. 迪米特法则
  - 尽量少与其他实体发生作用

## 六个创建模式

1. 简单工厂模式
  - 即创建交给工厂，由工厂辨别类型
2. 工厂方法模式
  - 每一个类型一个工厂，类型可以写在配置文件里，符合开闭原则
3. 抽象工厂模式
  - 解决上述工厂过多问题，常用在产品族里
  - 将工厂也抽象一层，产品也抽象一层
  - 每个抽象工厂都提供方法创建创建不同的产品，但是抽象产品层下的产品都是同一类型的
4. 单例模式
  - 防止实力过多竞争而产生混乱，只允许一个实例存在
  - 饿汉式单例，懒汉式单例
  - 更好的单例模式：IoDH 模式（Java 使用静态内部类实现）
5. 原型模式
  - 其实就是模板，然后返回模板复制后的对象
6. 建造者模式
  - 拥有一个指挥家，指挥如何建造一个对象或者模块
  - 指挥家可以抽象，具体如何建造交给具体指挥家
  - 外部对如何建造所要求的东西无需关心

## 七个结构模式

1. 适配器模式
  - 夹在调用者和被调用者之间进行适配
  - 通常有调用者的名字，但是实际上调用被调用者的方法
  - 因为两者名字不同，所以无法直接调用，所以需要适配
2. 桥接模式
  - 一抽象模块 A 维持一个对另一抽象模块 B 的引用
  - A 可以独自扩展，B 也可以独自扩展
  - A 中有方法使用抽象模块 B 即可
  - 此时的抽象模块 B 和使用 B 的方法即为“桥”
3. 组合模式
  - 分为透明组合和安全组合
  - 透明组合中，抽象父模块拥有所有子模块的方法，即使某些模块不支持当某其他模块的一些方法，针对父模块编程可以透明
  - 安全组合中，抽象父模块只拥有所有模块共有的方法，针对父模块编程非常安全，但某些特殊功能需要针对其子模块编程
  - 组合模式，即对一些子模块进行组合，抽象出父模块，针对父模块编程
4. 装饰模式
  - 将原模块添加到一个新模块中，使得原模块有更多的功能
  - 类似于代理模式
5. 外观模式
  - 对外提供一个模块，所有用户向该模块发起请求
  - 该模块负责调度内部系统，外部无需关心
  - 类似于中介者模式
6. 享元模式
  - 防止大量重复对象诞生，建造一个享元复用池，所有重复对象可以从池里得到一个相同对象
  - 若有不同属性，可以利用装饰模式等其他模式进行包装
7. 代理模式
  - 一个中介，外部无需关心访问的流程处理，一切均交给代理对象处理
  - 类似 顾客->房屋中介->房屋，房屋中介就是代理，处理购房事宜，房产证等

## 十一个行为模式

1. 职责链模式
  - 一个 Handler 分发处理请求
  - 请求分发，链式调用
2. 命令模式
  - 命令单独封装成模块
  - 其他模块调用命令，解耦发出者和执行者
3. 解释器模式
  - 自定义语言用
  - 和编译原理差不多，详见抽象语法树、词法分析、语法分析、语义分析等
4. 迭代器模式
  - 遍历数据交给迭代器，解耦存储数据和遍历数据
5. 中介者模式
  - 处理多对多复杂情况
  - 引入中介者，各终端持有对中介者的引用
6. 备忘录模式
  - 一般用于撤销和重做
  - 执行一步保存一个状态，可以用栈，List 等等
7. 观察者模式
  - 被观察者维护观察者列表
  - 被观察者改变，其自动遍历观察者进行通知
  - 所以也称发布-订阅模式
8. 状态模式
  - 状态判断封装为一个模块，维护状态模块
  - 每个状态下不同行为，在具体状态里实现
  - 上下文状态切换，调不同状态的共同方法，具体状态会执行各自逻辑
9. 策略模式
  - 跟上面状态模式差不多
  - 所有策略，名字不同，方法相同但实现不同
  - 上下文策略选择，只选择策略名字
10. 模板方法模式
  - 公共流程抽象到父模块，父模块只定义执行框架
  - 父模块执行到某抽象步骤，将推迟到子模块里执行
11. 访问者模式
   - 非常复杂
   - 抽象的被访问者定义某抽象访问方法，供抽象的访问者调用，具体的被访问者需实现该抽象方法
   - 抽象的访问者面向具体的被访问者定义一堆抽象方法供具体访问者实现
   - 具体访问者针对该些抽象方法实现，被访问者会自动执行访问方法

## 后注

> 模式从不保证任何东西，
>
> 它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。
>
> 模式并不能替代人来完成软件系统的创造，
>
> 它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。
>

