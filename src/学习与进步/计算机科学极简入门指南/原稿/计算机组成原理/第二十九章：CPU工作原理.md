# CPU 工作原理

## 复习

1. 了解了 CPU 的基本组成部分
2. 掌握了指令系统的基础知识
3. 理解了控制器的功能

## TL;DR

- CPU 通过取指、译码、执行的循环来处理指令
- 数据在寄存器、 ALU 和存储器之间流动
- 控制信号协调各部件的工作
- 时钟信号同步所有操作

## 正文

### 从程序到机器码

#### 1. 程序执行过程

1. **高级语言示例**：
   ```c
   int a = 5;
   int b = 3;
   int c = a + b;
   ```

2. **汇编语言表示**：
   ```assembly
   MOV R1, #5    ; a = 5
   MOV R2, #3    ; b = 3
   ADD R3, R1, R2 ; c = a + b
   ```

3. **机器码形式**：
   ```
   0010 0001 0000 0101  ; MOV R1, #5
   0010 0010 0000 0011  ; MOV R2, #3
   0000 0011 0001 0010  ; ADD R3, R1, R2
   ```

### CPU 执行周期

#### 1. 取指令阶段

1. **基本步骤**：
   ```
   时钟周期 1：
   PC -> MAR      ; 程序计数器的值送到地址寄存器
   M[MAR] -> MDR  ; 从内存读取指令到数据寄存器
   MDR -> IR      ; 将指令送入指令寄存器
   PC + 4 -> PC   ; 程序计数器加 4（32 位系统）
   ```

2. **示例**：
   ```
   PC = 1000      ; 当前指令地址
   M[1000] = ADD R1, R2, R3  ; 内存中的指令
   IR = "ADD R1, R2, R3"     ; 指令进入 IR
   PC = 1004      ; 准备取下一条指令
   ```

#### 2. 译码阶段

1. **指令分析**：
   ```
   操作码解析：ADD -> 算术加法
   操作数分析：
   - R1：目标寄存器
   - R2：源操作数 1
   - R3：源操作数 2
   ```

2. **控制信号生成**：
   ```
   ALU_OP = ADD     ; ALU 执行加法
   REG_READ = R2, R3 ; 读取源寄存器
   REG_WRITE = R1   ; 写入目标寄存器
   ```

#### 3. 执行阶段

1. **数据流动**：
   ```
   R2 -> ALU 输入 1
   R3 -> ALU 输入 2
   ALU 输出 -> R1
   ```

2. **示例操作**：
   ```
   如果：
   R2 = 5
   R3 = 3
   则：
   ALU 计算：5 + 3 = 8
   结果：R1 = 8
   ```

### 实际执行过程

#### 1. 简单程序示例

1. **计算 (a + b) * c**：
   ```c
   int a = 2;
   int b = 3;
   int c = 4;
   int result = (a + b) * c;
   ```

2. **汇编代码**：
   ```assembly
   MOV R1, #2    ; a = 2
   MOV R2, #3    ; b = 3
   MOV R3, #4    ; c = 4
   ADD R4, R1, R2 ; R4 = a + b
   MUL R5, R4, R3 ; result = R4 * c
   ```

3. **执行流程**：
   ```
   时钟周期 1：取指令 MOV R1, #2
   时钟周期 2：执行 R1 = 2
   时钟周期 3：取指令 MOV R2, #3
   时钟周期 4：执行 R2 = 3
   时钟周期 5：取指令 MOV R3, #4
   时钟周期 6：执行 R3 = 4
   时钟周期 7：取指令 ADD R4, R1, R2
   时钟周期 8：执行 R4 = 5
   时钟周期 9：取指令 MUL R5, R4, R3
   时钟周期 10：执行 R5 = 20
   ```

#### 2. 条件分支示例

1. **源代码**：
   ```c
   if (x > 0) {
       y = 1;
   } else {
       y = 0;
   }
   ```

2. **汇编代码**：
   ```assembly
   CMP R1, #0    ; 比较 x 和 0
   BLE ELSE      ; 如果 x <= 0，跳转到 ELSE
   MOV R2, #1    ; y = 1
   JMP END       ; 跳转到结束
   ELSE:
   MOV R2, #0    ; y = 0
   END:
   ```

3. **执行流程**：
   ```
   假设 R1 = 2：
   1. 执行 CMP，设置标志位
   2. 执行 BLE，因为 R1 > 0，继续
   3. 执行 MOV R2, #1
   4. 执行 JMP，跳到 END
   
   假设 R1 = -1：
   1. 执行 CMP，设置标志位
   2. 执行 BLE，因为 R1 < 0，跳转到 ELSE
   3. 执行 MOV R2, #0
   ```

### 性能优化实例

#### 1. 流水线执行

1. **无流水线**：
   ```
   指令 1：|取指|译码|执行|写回|
   指令 2：        |取指|译码|执行|写回|
   指令 3：                |取指|译码|执行|写回|
   ```

2. **有流水线**：
   ```
   指令 1：|取指|译码|执行|写回|
   指令 2：    |取指|译码|执行|写回|
   指令 3：        |取指|译码|执行|写回|
   ```

#### 2. 数据冒险处理

1. **代码示例**：
   ```assembly
   ADD R1, R2, R3 ; R1 = R2 + R3
   SUB R4, R1, R5 ; R4 = R1 - R5
   ```

2. **转发解决**：
   ```
   时钟周期 1：ADD 指令执行
   时钟周期 2：ADD 结果直接转发给 SUB 指令
   ```

### 思考题

> 　　 在一个简单的 CPU 中，如何优化以下代码的执行？
> ```c
> for(int i = 0; i < 100; i++) {
>     sum += array[i];
> }
> ```

## 小结

### 知识点

- CPU 执行指令的基本周期
- 数据通路和控制通路的协作
- 分支和循环的处理机制
- 性能优化技术

### 思考题答案（仅供参考）

　　 优化建议：

1. **循环展开**：
   ```assembly
   ; 每次处理多个元素
   LDR R1, [R0], #4  ; 加载 array[i]
   LDR R2, [R0], #4  ; 加载 array[i+1]
   ADD R3, R3, R1    ; sum += array[i]
   ADD R3, R3, R2    ; sum += array[i+1]
   ```

2. **预取数据**：
   - 提前加载下一轮循环的数据
   - 利用缓存机制

3. **分支预测**：
   - 循环计数器预测
   - 减少分支判断

## 参考资料

1. [Wikipedia(zh)：指令周期](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F)：CPU 执行指令的基本过程
2. [Wikipedia(zh)：流水线](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%B7%9A%E5%8C%96)：指令流水线的工作原理
3. [Wikipedia(zh)：数据冒险](https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A%E5%86%92%E9%9A%AA)：流水线中的数据冒险问题

## 协议

　　 本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
