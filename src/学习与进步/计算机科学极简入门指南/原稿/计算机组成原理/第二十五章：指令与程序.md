# 指令与程序

## 复习

11. 理解了时钟信号的作用和重要性，以及如何用它同步电路操作
12. 掌握了时序逻辑电路的基本原理，包括状态机、计数器等
13. 了解了指令的基本概念、格式和类型，以及指令执行的基本周期

## TL;DR

- 程序是指令的有序序列
- 指令的执行顺序可以是顺序的，也可以是跳转的
- 程序计数器（PC）用于跟踪当前执行的指令
- 程序的执行需要配合存储器和寄存器

## 正文

### 从单条指令到程序

　　在上一章中，我们学习了单条指令的结构和执行。但实际问题的解决往往需要多条指令的配合。

#### 1. 程序的概念

1. **定义**：
   - 按特定顺序排列的指令序列
   - 用于完成特定的任务
   - 存储在计算机内存中

2. **特点**：
   - 顺序性：指令通常按顺序执行
   - 可控性：可以改变执行顺序
   - 可重复性：可以多次执行

### 程序执行的基本机制

#### 1. 程序计数器（PC）

1. **功能**：
   - 存储下一条要执行的指令地址
   - 通常自动递增
   - 可以被跳转指令修改

2. **工作过程**：
   - 取指令时使用 PC 的值
   - 指令执行后 PC 更新
   - 跳转时 PC 被修改

#### 2. 指令执行序列

1. **顺序执行**：
   ```
   MOV R1, #5    ; PC = 100
   ADD R2, R1, #3; PC = 104
   SUB R3, R2, #1; PC = 108
   ```

2. **条件跳转**：
   ```
   CMP R1, #0    ; 比较 R1 和 0
   BEQ ZERO      ; 如果相等，跳转到 ZERO
   ADD R2, R1, #1; 否则执行这条指令
   JMP NEXT      ; 无条件跳转到 NEXT
   ZERO:
   MOV R2, #0    ; R1 等于 0 时执行
   NEXT:
   ...
   ```

### 程序示例

#### 1. 计算 1 到 N 的和

```assembly
    MOV R1, #5    ; N = 5
    MOV R2, #0    ; sum = 0
    MOV R3, #1    ; i = 1
LOOP:
    CMP R3, R1    ; 比较 i 和 N
    BGT END       ; 如果 i > N，跳转到结束
    ADD R2, R2, R3; sum = sum + i
    ADD R3, R3, #1; i = i + 1
    JMP LOOP      ; 继续循环
END:
    ; R2 中存储最终结果
```

#### 2. 查找最大值

```assembly
    MOV R1, #ARRAY ; 数组起始地址
    MOV R2, #5     ; 数组长度
    LDR R3, [R1]   ; max = 第一个元素
    MOV R4, #1     ; i = 1
LOOP:
    CMP R4, R2     ; 比较 i 和长度
    BEQ END        ; 如果相等，结束
    LDR R5, [R1,R4]; 加载当前元素
    CMP R5, R3     ; 比较当前元素和最大值
    BLE NEXT       ; 如果小于等于，跳过
    MOV R3, R5     ; 更新最大值
NEXT:
    ADD R4, R4, #1 ; i++
    JMP LOOP       ; 继续循环
END:
    ; R3 中存储最大值
```

### 程序设计考虑

#### 1. 结构化编程

1. **基本结构**：
   - 顺序结构
   - 选择结构（if-then-else）
   - 循环结构（while, for）

2. **实现方法**：
   - 使用条件跳转
   - 使用循环控制
   - 合理组织代码块

#### 2. 程序优化

1. **空间优化**：
   - 减少指令数量
   - 重用寄存器
   - 优化数据存储

2. **时间优化**：
   - 减少跳转次数
   - 利用流水线特性
   - 优化循环结构

**思考题**

> 　　如何修改"计算 1 到 N 的和"的程序，使其能同时计算平均值？

## 小结

### 知识点

- 程序的基本概念和特点
- 程序计数器的作用
- 基本程序结构
- 程序优化方法

### 思考题答案（仅供参考）

　　修改程序计算平均值：
```assembly
    MOV R1, #5    ; N = 5
    MOV R2, #0    ; sum = 0
    MOV R3, #1    ; i = 1
LOOP:
    CMP R3, R1    ; 比较 i 和 N
    BGT CALC_AVG  ; 如果 i > N，计算平均值
    ADD R2, R2, R3; sum = sum + i
    ADD R3, R3, #1; i = i + 1
    JMP LOOP      ; 继续循环
CALC_AVG:
    SUB R3, R3, #1; R3 = N
    DIV R4, R2, R3; R4 = sum / N（平均值）
END:
    ; R2 中存储和，R4 中存储平均值
```

## 参考资料

1. [Wikipedia(zh)：程序计数器](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%88%E6%95%B8%E5%99%A8)：程序计数器的基本概念
2. [Wikipedia(zh)：结构化编程](https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B)：结构化编程的原理
3. [Wikipedia(zh)：汇编语言](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80)：汇编语言编程基础

## 协议

　　本作品采用[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可。
