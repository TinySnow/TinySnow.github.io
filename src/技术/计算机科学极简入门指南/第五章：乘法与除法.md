# 第五章：乘法与除法

## 复习

- 第一章：希望造出一台计算机。
- 第二章：这台计算机需要供能，输入，输出和处理过程。
- 第三章：利用电能和布尔代数，造出了一个加法器。
- 第四章：引入有符号数，介绍原码、反码和补码，使计算机可以表示负数和运算减法。

## 正文

### 乘法

#### 本质

　　加减法有了，乘除法呢？加法有了，逆运算的减法也就有了，而除法是乘法的逆运算，问题应该也不大。

　　回忆小学怎样算乘法。列竖式，相加。乘法本质是反复加法。

　　十进制可以这样算，二进制呢？

#### 逐位相乘

　　不妨来试试： `3 × 5 = 15`。 <u>简单起见，使用无符号数，没有符号位。</u>

```
    0011   （3 的无符号二进制）
×   0101   （5 的无符号二进制）
--------
    0011
   0000#    <-- # 表示占位符，没有意义
+ 0011##
--------
    1111   （15 的无符号二进制）
```

　　可见竖式也能得出正确结果：`0011` × `0101` = `1111`<sub>2 进制无符号</sub>，也即 `15`<sub>10</sub>。

　　那就好办了，让一个二进制数，与另一个二进制数的 <u>每一位</u> 相乘，然后进行竖式一样的 <u>移位</u> 操作，最后加在一起就好了。因为补码可以参与运算，所以负数的乘法也解决了，下面就是实现了。

　　相乘，仔细观察可以用 and（与门）解决，那——**移位** 呢？该怎么办？

#### Booth 算法

　　Booth 算法是一种针对二进制补码的乘法算法，可以将时间复杂度降低到 $O(n)$，同时也比逐位相乘更适合硬件实现。

　　Booth 算法的核心思想是：对于二进制补码的每一位，我们可以通过判断它与它前一位的关系，来决定是否进行加减操作。

　　以 `1010`<sub>2</sub> × `1101`<sub>2</sub> 为例：

- 第一步：在乘数最后面补一个 0，得到 `10100`<sub>2</sub>，表示 $2 \times 1010$。
- 第二步：从右往左，取出两位作为判断基准。判断基准共有三种情况：
  - `00`：不操作；
  - `01`：将被乘数减去乘数；
  - `10`：将被乘数加上乘数。
- 第三步：将判断基准向左移一位，继续循环判断，直到乘数的所有位都处理完毕。

　　具体实现可以看下面的表格：

| 被乘数  | 判断基准 | 操作 | 乘数   |
| ------- | -------- | ---- | ------ |
| `10100` | `00`     | #    | `1101` |
| `10100` | `00`     | #    | `1101` |
| `10100` | `01`     | -    | `1101` |
| `10100` | `10`     | +    | `1101` |
| `10101` | `10`     | +    | `1101` |

　　最终结果为 `111110`<sub>2</sub>，转换为十进制为 `62`。

### 移位

　　我们没有介绍过移位，但应该能想到，上面乘法移位最简单的方式，就是在最后一位后面补零，同时丢掉最高位：`0011` 不补零，`0000` 补一个，`0011` 补两个。

**思考题**

> 　　我们现在只有加法器，应该怎样移位和补零？以及， **设计一个最简单的乘法器，真的需要移位吗？**

### 除法

#### 本质

　　除法是乘法的逆运算，本质是反复减法。

　　例如，我们要计算 `12 ÷ 3`，可以看作是不断从 `12` 中减去 `3` 直到不能再减为止：

```
12 - 3 = 9
9 - 3 = 6
6 - 3 = 3
```

　　因此，得到结果 `4`。

　　但这种实现方式效率低下，需要进行多次减法运算。因此，为了提高运算效率，我们通常使用更高效的算法来实现除法。

#### 短除法

　　短除法也是我们平常手算除法的方式：先将被除数的高位和除数对齐，然后用除数去除被除数，得到商和余数，再将余数和下一位对齐，继续除，直到被除数的所有位都处理完毕或者余数为 0。

　　以 `10110`<sub>2</sub> ÷ `101`<sub>2</sub> 为例：

```
      10
   _______
101|10110
    101
    ---
    100
    101
    ---
      1
```

　　上面的表格中，每一行的第一列为商，第二列为余数，第三列为下一位被除数。最终商为 `100`<sub>2</sub>，余数为 `1`<sub>2</sub>。

　　短除法的时间复杂度为 $O(n)$，与位数成正比。但是如果除数的位数较大，短除法的效率会比较低。此时，可以采用更高效的除法算法，如牛顿迭代法、二分法等。

#### 除法的基本算法

　　除法的基本算法是长除法，也叫做列竖式除法。

　　例如，我们要计算 `345 ÷ 67`：

```
     5
  ------
 67|345
    335
    ---
     10
      9
     ---
      6

```

　　具体步骤如下：

1. 将被除数和除数竖列在一起，以个位数为基准。
2. 将第一个被除数的位与除数进行比较，看能否整除。
3. 如果能整除，则在商的下一位写入商的一位，否则在商的下一位写入 `0`。
4. 将除数乘以商的一位，得到一个中间结果。
5. 将中间结果从被除数中减去，得到新的被除数。
6. 重复上述步骤，直到被除数小于除数为止，此时商的值即为最终结果。

　　长除法的优点是计算精确，适用于小规模的计算。但对于大规模的计算，长除法效率太低，需要更高效的算法。

#### 快速除法

　　快速除法采用二进制计算的思路，将除法转化为位运算，从而大大提高了计算速度。

　　例如，我们要计算 `12 ÷ 3`：

```
12 ÷ 3 = (1100)_2 ÷ (11)_2 = 100
```

　　具体步骤如下：

1. 将被除数和除数转化为二进制数。
2. 将被除数的每一位（从左往右）与除数相除，得到若干个二进制数。
3. 对这些二进制数进行相加，得到最终结果。

　　快速除法的优点是计算速度快，适用于大规模的计算。但需要注意的是，快速除法只适用于整数的除法运算。同时，快速除法可能会导致精度损失，需要进行额外的处理。

　　除法是指将一个数除以另一个数得到商和余数的过程。在计算机中，除法通常使用移位和减法操作来实现，这被称为 **<u>位移除法</u>**。下面是一个例子：

- `14 ÷ 3 = 4 余 2`

　　首先将 14 和 3 转换为二进制数 `1110` 和 `0011`。接下来使用下面的算法：

- 将被除数（14）左移一位，得到 `11100`。
- 如果左移后的结果大于或等于除数（3），则将该结果减去除数，并在商的相应位上置 1。
- 将被除数左移一位，重复上述步骤，直到被除数小于除数为止。

　　使用上述算法，可以得到以下结果：

- `1110 ÷ 0011 = 100 余 010`，即 `4 余 2`。

　　在计算机中，左移和减法操作通常使用移位运算符 `<<` 和 `-` 实现，例如：

```c
int a = 14; // 二进制为 1110
int b = 3; // 二进制为 0011
int q = 0; // 商的初始值为 0
int r = a; // 余数的初始值为被除数

while (r >= b) {
  r = r << 1; // 左移一位
  q = q << 1; // 左移一位
  if (r >= b) {
    r = r - b; // 减去除数
    q = q + 1; // 商的相应位上置 1
  }
}
```

　　在上面的代码中，`r`表示余数，初始值为被除数；`q` 表示商的值，初始值为 0。在循环中，首先将余数左移一位，然后判断左移后的结果是否大于或等于除数，如果是，则将余数减去除数，并在商的相应位上置 1。重复上述步骤直到余数小于除数为止，最后得到的商就是 `4`，余数就是 `2`。

### 总结

　　本章介绍了乘法和除法的基本原理，以及在计算机中如何实现乘法和除法运算。乘法通常使用加法和移位操作来实现，而除法通常使用移位和减法操作来实现。在实际编程中，可以使用移位运算符 `<<` 和 `-` 来实现位移除法。

